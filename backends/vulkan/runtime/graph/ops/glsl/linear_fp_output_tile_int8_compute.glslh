/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using int8 input and weight tiles.
 *
 * Settings:
 * - TILE_M: The number of rows in the output tile.
 * - TILE_N4: The number of (groups of 4) columns in the output tile.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_INT8_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_INT8_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require

#include "linear_common.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_int8_input_tile.glslh"
#include "linear_int8_weight_tile.glslh"

// Stores integer accumulators for an output tile.
struct Int8OutAccum {
  ivec4 data[TILE_M][TILE_N4];
};

// Initialize values to 0
void initialize(out Int8OutAccum out_accum) {
#if TILE_M > 1 && TILE_N4 == 1
  [[unroll]] for (int y = 0; y < TILE_M; ++y) {
    out_accum.data[y][0] = ivec4(0);
  }

#else
  [[unroll]] for (int y = 0; y < TILE_M; ++y) {
    [[unroll]] for (int x4 = 0; x4 < TILE_K4; ++x4) {
      out_accum.data[y][x4] = ivec4(0);
    }
  }
#endif
}

// Accumulate int8 input and weight tiles into accumulator tile
void accumulate(
    inout Int8OutAccum accum,
    Int8InputTile in_tile,
    Int8WeightTile w_tile) {
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    const int m4 = div_4(m);
    const int m4i = mod_4(m);
    [[unroll]] for (int n = 0; n < TILE_N; ++n) {
      const int n4 = div_4(n);
      const int n4i = mod_4(n);
      [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
        accum.data[m][n4][n4i] = dotPacked4x8AccSatEXT(
            in_tile.data[m4][k4][m4i],
            w_tile.data[k4][n4][n4i],
            accum.data[m][n4][n4i]);
      }
    }
  }
}

/*
 * Computes final weight matrix output tile using:
 * - int8 accumulator tile
 * - per output channel weight sums
 * - per output channel scales
 */
void compute(
    out FPOutTile out_tile,
    const Int8OutAccum out_accum,
    const FPPerOutChannelParams sums,
    const FPPerOutChannelParams scales) {
#if TILE_M > 1 && TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    out_tile.data[m][0] =
        (VEC4_T(out_accum.data[m][0]) - input_zp * sums.data[0]) *
        scales.data[0] * input_scale;
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      out_tile.data[m][n4] =
          (VEC4_T(out_accum.data[m][n4]) - input_zp * sums.data[n4]) *
          scales.data[n4] * input_scale;
    }
  }
#endif
}

void compute(
    out FPOutTile out_tile,
    const Int8OutAccum out_accum,
    const FPPerOutChannelParams sums,
    const FPPerOutChannelParams scales,
    const FPPerOutChannelParams bias) {
#if TILE_M > 1 && TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    out_tile.data[m][0] =
        (VEC4_T(out_accum.data[m][0]) - input_zp * sums.data[0]) *
            scales.data[0] * input_scale +
        bias.data[0];
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      out_tile.data[m][n4] =
          (VEC4_T(out_accum.data[m][n4]) - input_zp * sums.data[n4]) *
              scales.data[n4] * input_scale +
          bias.data[n4];
    }
  }
#endif
}

#endif // LINEAR_FP_OUTPUT_TILE_INT8_COMPUTE_GLSLH
