/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef CONV2D_FP_IM2COL_BLOCK_STORE
#define CONV2D_FP_IM2COL_BLOCK_STORE

/*
 * Defines utilities to store data for a 4x4 im2col output matrix block computed
 * from matrix multiplication to an output image.
 *
 * Requires:
 * - t_output to be defined in the shader layout, representing the texture of
 *   the output image
 */

#extension GL_EXT_control_flow_attributes : require

#include "common.glslh"
#include "conv2d_common.glslh"
#include "conv2d_fp_im2col_block.glslh"
#include "linear_fp_output_tile.glslh"

// TODO: implement buffer support
void write_output_texel(const VEC4_T out_texel, const TensorIndex4D tidx) {
  // Assume batch size is 1
  if (true && tidx.data.x == 2 && tidx.data.y == 1 && div_4(tidx.data.z) == 0) {
    debugPrintfEXT(
        "write_output_texel: %d %d %d %d / %f %f %f %f \\n",
        tidx.data.x,
        tidx.data.y,
        tidx.data.z,
        tidx.data.w,
        out_texel.x,
        out_texel.y,
        out_texel.z,
        out_texel.w);
  }
  imageStore(
      t_output, ivec3(tidx.data.x, tidx.data.y, div_4(tidx.data.z)), out_texel);
}

void write_im2col_tile_as_image(
    const FPOutTile tile,
    const int n4_start,
    const int m_start) {
  Im2ColTensorIdx im2col_tidx;
  im2col_tidx.col = mul_4(n4_start);
  im2col_tidx.row = m_start;
#if TILE_K4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    TensorIndex4D output_tidx;
    im2col_tidx_to_output_tidx(output_tidx, im2col_tidx);

    if (any(greaterThanEqual(output_tidx.data, output_sizes))) {
      continue;
    }
    if (false) {
      debugPrintfEXT(
          "%d %d: im2col idx: %d, %d --> output_tidx: %d %d %d %d / %f %f %f %f \\n",
          n4_start,
          m_start + m,
          im2col_tidx.col,
          im2col_tidx.row,
          output_tidx.data.x,
          output_tidx.data.y,
          output_tidx.data.z,
          output_tidx.data.w,
          tile.data[m][0].x,
          tile.data[m][0].y,
          tile.data[m][0].z,
          tile.data[m][0].w);
    }
    // int val = (output_tidx.data.x + 1) * 100000 +
    //           (output_tidx.data.y + 1) * 1000 +
    //           (output_tidx.data.z + 1);
    // VEC4_T test_texel = texelFetch(t_input, ivec3(n4_start, m_start + m, 0),
    // 0);
    write_output_texel(tile.data[m][0], output_tidx);
    im2col_tidx.row++;
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
      TensorIndex4D output_tidx;
      im2col_tidx_to_output_tidx(output_tidx, im2col_tidx);

      write_output_texel(tile.data[m][k4], output_tidx);
      im2col_tidx.row++;
    }
  }

#endif
}

#endif // CONV2D_FP_IM2COL_BLOCK_STORE
